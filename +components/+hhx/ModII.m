% Mod II / Mod I Hot Heat Exchanger
%
% TODO: Update the below comment when component is finalized:
%
% This model of the Mod I hot heat exchanger is for the staggered two row tube
% bank (first row is unfinned and second row is finned).  The model assumes that
% T_hot is the hottest tube temperature and models the combustion system with an
% efficiency.  The blower power and atomizing air compressor power are computed
% based on engine speed and power.  The mass flow rate of fuel is computed based
% on heat release and the flow rate of air over the heat exchanger is computed
% using an assumed value of recirculation.

classdef ModII < handle
    properties (Constant)
        defaultParams = struct(                ...
            "geometry", struct(                ...
                "tubes", struct(               ...
                    "L_front", 0.15,           ...   "active length of front row of tubes (m)"
                    "L_rear", 0.1075,          ...   "active length of rear row of tubes (m)"
                    "L_inactive", 0.018,       ...   "inactive length of tubes (m)"
                    "D_outer", 0.0045,         ...   "outer diameter of tubes (m)"
                    "D_inner", 0.003,          ...   "inner diameter of tubes (m)"
                    "roughness", 1e-5,         ...   "roughness of inside surface of tube (m)"
                    "N_total", 24,             ...   "total number of tubes per cylinder"
                    "materialtube", "SS304",   ...   "tube material (must be in Solid.m)"
                    "materialfin", "Multimet"  ...   "fin material (must be in Solid.m)"
                ),                             ...
                "shell", struct(               ...
                    "R_outer", 0.161,          ...   "radius associated with outer row tube centers (m)"
                    "R_inner", 0.084,          ...   "radius associated with inner row tube centers (m)"
                    "V_header", 30e-6          ...   "void volume that is outside of the tubes (m^3)"
                ),                             ...
                "fins", struct(                ...
                    "thickness", 0.0006,       ...   "thickness of fins on outer row (m)"
                    "pitch", 0.0013,           ...   "pitch (distance from center of fin to center of fin) (m)"
                    "L_fin", 0.01              ...   "fin length in flow direction (m)"
                )                              ...
            ),                                 ...
            "correlation", "oscillating"       ...   "type of correlation to use for flow in tube, oscillating or steady"
        )
    end

    properties (SetAccess = private)
        % Interface Properties
        vol (1,1) double {mustBeReal}
        DT (1,1) double {mustBeReal}
        W_parasitic (1,1) double {mustBeReal}
        Q_parasitic (1,1) double {mustBeReal}
        DP (1,:) double {mustBeReal}

        % Internal Properties
        R_hyd (1,1) double
        L_f (1,1) double
        L_r (1,1) double
        L_ia (1,1) double
        D_t_o (1,1) double
        D_t_i (1,1) double
        roughness (1,1) double
        N_t (1,1) double
        R_in (1,1) double
        R_out (1,1) double
        V_h (1,1) double
        th_f (1,1) double
        p_f (1,1) double
        L_fin (1,1) double
        correlation (1,1) string
        materialtube (1,1) string
        materialfin (1,1) string
        eta_c (1,1) double
        rpt (16,1) double
    end

    methods
        function obj = ModII(params)
            obj.L_f = params.geometry.tubes.L_front;
            obj.L_r = params.geometry.tubes.L_rear;
            obj.L_ia = params.geometry.tubes.L_inactive;
            obj.D_t_o = params.geometry.tubes.D_outer;
            obj.D_t_i = params.geometry.tubes.D_inner;
            obj.roughness = params.geometry.tubes.roughness;
            obj.N_t = params.geometry.tubes.N_total;
            obj.materialtube = params.geometry.tubes.materialtube;
            obj.materialfin = params.geometry.tubes.materialfin;
            obj.R_in = params.geometry.shell.R_inner;
            obj.R_out = params.geometry.shell.R_outer;
            obj.V_h = params.geometry.shell.V_header;
            obj.th_f = params.geometry.fins.thickness;
            obj.p_f = params.geometry.fins.pitch;
            obj.L_fin = params.geometry.fins.L_fin;
            obj.correlation = params.correlation;

            % Calculate fluid volume inside tubes
            obj.vol = (obj.L_f + obj.L_r + obj.L_ia) * obj.N_t * pi * obj.D_t_i^2 / 4 + obj.V_h;
            
        end

        function firstCallUpdate(obj, engine)
            % Provide an initial guess value for DT (before engine states are available)
            obj.DT = min(10, 0.01 * (engine.T_hot - engine.T_cold));
            obj.rpt = zeros(16,1);
        end

        function update(obj, engine)
            % Update the value for DT based on the current engine state

            % Get total heat transfer rate
            Q_dot_e = 0;
            if ~isinf(engine.ws.R_e)
                Q_dot_e = engine.freq * trapz(                             ...
                    engine.stateValues.time,                               ...
                    (engine.T_l - engine.stateValues.T_e) / engine.ws.R_e  ...
                );
            end
            Q_dot_l = engine.freq * trapz(  ...
                engine.stateValues.time,    ...
                engine.stateValues.Q_dot_l  ...
            );
            Q_dot_avg = Q_dot_e + Q_dot_l;

            % Calculate average mass flow rate in the hxr
            m_dot_avgs = 0.5 * (engine.stateValues.m_dot_rl + engine.stateValues.m_dot_le);
            m_dot_avg = engine.freq * trapz(  ...
                engine.stateValues.time,      ...
                abs(m_dot_avgs)               ...
            );

            % Calculate average fluid properties in the HHX
            fluidProps = engine.fluid.allProps(engine.T_l, engine.P_ave);

            C_dot_avg = fluidProps.CP * m_dot_avg;  %average capacitance rate (W/K)
            rho_g = fluidProps.rho;  %average fluid density

            % Working fluid side calculations
            %--------------------------------
            %steady flow friction and htc
            L_t = (obj.L_f + obj.L_r + obj.L_ia);  %total length of tube
            [DP_tube, htc_g] = util.tubeFlow(fluidProps, m_dot_avg/obj.N_t, obj.D_t_i, L_t, obj.roughness, 1);
            
            %get minor loss
            K_h = 10; %assumed total minor loss coefficient (expansion/contraction and bend)
            Ac_g = pi * obj.D_t_i^2 / 4 * obj.N_t;  %cross-sectional area for flow in tubes
            u_g_avg = m_dot_avg / (rho_g * Ac_g);   %average velocity

            DP_minor = K_h*rho_g*u_g_avg^2/2;   %minor loss
            
            DP_g = DP_tube+DP_minor;  %total steady pressure loss
            
            if (obj.correlation == "oscillating")
                u_max=u_g_avg*sqrt(2);  %approximate max velocity
                [MF_DP, MF_h] = util.oscillatingFlow(fluidProps, obj.D_t_i, engine.freq, u_max);  %get oscillating flow multipliers
                DP_g = MF_DP*DP_g;
                htc_g = MF_h*htc_g;
            end
   
            obj.R_hyd = DP_g / (m_dot_avg / rho_g);            
            
            % Combustion gas side calculations
            %--------------------------------
            PEA = 2.1;  %excess air - air flow/stoichiometric air flow
            SAF = 14.5; %stoichiometric air fuel ratio for diesel
            CGF = 1.7;  %combustion gas recirculation ratio
            AF = PEA*SAF; %air-fuel ratio
            HHV = 44.8e6; %higher heating value of diesel fuel (J/kg)
            Q_dot_in = (Q_dot_avg + engine.ws.Q_parasitic_e + engine.regen.Q_parasitic);  %total heat transfer to engine less combustion system loss
            m_dot_f_0 = Q_dot_in/(HHV*0.9); %initial guess for fuel flow rate per cylinder
            m_dot_f = fzero(@(mf) 0.93*(1-exp(-(mf/0.00001)^0.5))*mf*HHV-Q_dot_in,m_dot_f_0); %solve to find fuel flow rate per cylinder - note this neglects fuel required for heat transfer parasitics
            obj.eta_c = 0.93*(1-exp(-(m_dot_f/0.00001)^0.5));  %combustion system efficiency
            obj.Q_parasitic = Q_dot_in*(1/obj.eta_c - 1);  %parasitic heat transfer from combustion system
            
            m_dot_a = m_dot_f*AF*(1+CGF); %air mass flow rate passing over hhx per cylinder
            
            P_a = 101325;  %assumed atmospheric pressure
            T_comb = 1800; %assume temperature of air entering hhx (K) - used only to get air properties
            T_a = (T_comb + engine.T_hot)/2;  %average temperature used to determine air properties
            rho_a = util.properties.IdealGasAir("dens", T_a, P_a);  %density
            c_a = util.properties.IdealGasAir("cp", T_a, P_a);  %specific heat capacity
            mu_a = util.properties.IdealGasAir("visc", T_a, P_a);  %viscosity
            k_a = util.properties.IdealGasAir("cond", T_a, P_a);  %thermal conductivity
            Pr_a = mu_a * c_a / k_a;  %Prandtl number
            
            u_f = m_dot_a / (pi * obj.R_in * obj.L_r * rho_a/2);  %note uses L_r because this established height and divides by 2 because perimeter is 2*pi*R/2
            [htc_f] = util.externalFlowCylinder(u_f, obj.D_t_o, mu_a, k_a, rho_a, Pr_a);  %get htc on front cylinder
            
            u_r = m_dot_a / (pi * obj.R_out * obj.L_r * rho_a/2);  %note uses L_r because this established height and divides by 2 because perimeter is 2*pi*R/2
            [htc_r] = util.externalFlowFinnedCylinder(u_r, obj.D_t_o, mu_a, k_a, rho_a, Pr_a); %get htc on rear finned tubes
            
            D_f=obj.R_out * pi/obj.N_t/2;  %distance between adjacent tubes - this should be approximately equal to L_fin and is taken as the fin diameter
            D_f = min(D_f, obj.L_fin);
            
            A_fin=(pi*(D_f^2-obj.D_t_o^2)*2*obj.L_r/obj.p_f/4+pi*D_f*obj.th_f*obj.L_r/obj.p_f)*obj.N_t;  %total finned surface area per cylinder
            A_unfin=pi*obj.D_t_o*obj.L_r*(obj.p_f-obj.th_f)/obj.p_f*obj.N_t;  %total unfinned surface area per cylinder
            eps=(A_fin+A_unfin)/A_unfin;  %ratio of total to unfinned area

            % Fin efficiency
            [~, ~, k_t] = util.properties.Solid(obj.materialfin, engine.T_hot);  %get conductivity of fin material
            mro=sqrt(2*htc_r/(k_t*obj.th_f))*(D_f/2);
            mri=sqrt(2*htc_r/(k_t*obj.th_f))*(obj.D_t_o/2);
            eta_fin = 2*mri*(besselk(1,mri)*besseli(1,mro)-besseli(1,mri)*besselk(1,mro))/((mro^2-mri^2)*(besseli(0,mri)*besselk(1,mro)+besselk(0,mri)*besseli(1,mro)));
    
            % Resistance to tube wall
            [~, ~, k_m] = util.properties.Solid(obj.materialtube, engine.T_hot);  %get conductivity of tube material
            R_t_f = log(obj.D_t_o / obj.D_t_i) / (2 * pi * k_m * obj.L_f * obj.N_t);  %thermal resistance of front tube wall
            R_t_r = log(obj.D_t_o / obj.D_t_i) / (2 * pi * k_m * obj.L_r * obj.N_t);  %thermal resistance of rear tube wall
            R_g_f = 1 / (htc_g * obj.N_t * obj.D_t_i * pi * obj.L_f);  %resistance to convection inside front heater tubes
            R_g_r = 1 / (htc_g * obj.N_t * obj.D_t_i * pi * obj.L_r);  %resistance to convection inside front heater tubes
            R_f = 1 / (htc_f * obj.N_t * obj.D_t_o * pi * obj.L_f);  %resistance to convection on outside of front tube
            R_r_fin=1/(htc_r*A_fin*eta_fin);  %resistance associated with fins on rear tube
            R_r_unfin=1/(htc_r*A_unfin);      %resistance associated with unfinned surface on rear tube
            R_r_total=R_t_r+R_g_r+(1/R_r_fin+1/R_r_unfin)^(-1); %total resistance of rear tube
            R_f_total = R_t_f + R_g_f + R_f;  %total resistance of front tube
            R_total=(1/R_f_total+1/R_r_total)^(-1); %total resistance
            UA = 1 / R_total;  %total conductance
            Rst_in = (1/(R_t_f + R_g_f)+1/(R_t_f + R_g_r))^(-1); %thermal resistance from tube material to working fluid
            
                       
            % Determine approach temperature difference
            C_dot_a = m_dot_a * c_a;    %capacitance rate of the air
            DT_a = Q_dot_avg/C_dot_a;   %temperature change of the air
            UA_in = 1/Rst_in;     %conductance of heat exchanger from metal to working fluid
            NTU_in = UA_in/C_dot_avg;  %NTU of heat exchanger from metal to working fluid
            eff_in = 1-exp(-NTU_in); %eff of heat exchanger from metal to working fluid
            obj.DT = Q_dot_avg/C_dot_avg * (1 / eff_in - 1);  %approach temperature - relative to T_hot, the tube temp.
            
            %Calculate combustion temp
            C_dot_min = min(C_dot_a, C_dot_avg);    %minimum cap. rate
            C_dot_max = max(C_dot_a, C_dot_avg);    %maximum cap. rate
            NTU = UA / C_dot_min;   %NTU of hhx
            Cr = C_dot_min / C_dot_max;  %cap ratio
            eff = (1 / (1 - exp(-NTU)) + Cr / (1 - exp(-Cr * NTU)) - 1 / NTU)^(-1);  %effectiveness of hhx
            DT_total = Q_dot_avg*(1/(eff*C_dot_min)-1/C_dot_avg);  %approach temp between combustion temp (air inlet temp) and T_l
            T_comb = engine.T_l + DT_total;  %approximate combustion temperature - should not be too different than assumed combustion temp.
            
            %parameters to be saved for report
            obj.rpt(1) = obj.eta_c;
            obj.rpt(2) = DP_tube;
            obj.rpt(3) = DP_minor;
            obj.rpt(4) = htc_g;
            obj.rpt(5) = m_dot_f;
            obj.rpt(6) = m_dot_a;
            obj.rpt(7) = htc_f;
            obj.rpt(8) = htc_r;
            obj.rpt(9) = UA;
            obj.rpt(10) = UA_in;
            obj.rpt(11) = eff;
            obj.rpt(12) = eff_in;
            obj.rpt(13) = T_comb;   
            obj.rpt(14) = DT_total;
        end

        function lastCallUpdate(obj, engine)
            % Update pressure drop values
            m_dot_avgs = 0.5 * (engine.stateValues.m_dot_rl + engine.stateValues.m_dot_le);
            rho = engine.fluid.density(engine.T_l, engine.stateValues.P);
            V_dot = m_dot_avgs ./ rho;
            obj.DP = obj.R_hyd * V_dot;
           
            W_dot_b_fp=(0.0527286352 + 0.00533039162*engine.freq + 0.000206641744*engine.freq^2)*1000;  %blower power per cylinder at full power (15 MPa)
            W_dot_ac_fp=(0.0644216051 + 0.00293865735*engine.freq + 0.000154701217*engine.freq^2)*1000;  %atomizing air compressor power per cylinder at full power
            
            W_dot_b_np=(0.0918608657 - 0.000355228306*engine.freq + 0.000161133161*engine.freq^2)*1000;  %blower power per cylinder at no load (taken to be 5 MPa)
            W_dot_ac_np=(0.0706625881 + 0.00033266001*engine.freq + 0.000145655642*engine.freq^2)*1000;  %atomizing air compressor power per cylinder at no load (taken to be 5 MPa)
            
            fp = (engine.P_ave - 5e6)/(10e6);  %fraction of full power
            W_dot_b = W_dot_b_np + (W_dot_b_fp - W_dot_b_np)*fp;  %blower power per cylinder
            W_dot_ac = W_dot_ac_np + (W_dot_ac_fp - W_dot_ac_np)*fp;  %atomizing air compressor per cylinder
            obj.W_parasitic = W_dot_b + W_dot_ac;
            obj.rpt(15) = W_dot_b;
            obj.rpt(16) = W_dot_ac;
        end
        
         function lines = report(obj)
            % Return a string array that will be included in the engine report
            % (This function is optional)
            lines = [
                sprintf("Percent efficiency of combustion system = %.4f", 100*obj.rpt(1)),
                sprintf("Parasitic heat loss = %.4f W", obj.Q_parasitic),
                sprintf("Mass flow rate of fuel (per cylinder) = %.4f g/s", obj.rpt(5)*1000),
                sprintf("Mass flow rate of air (per cylinder) = %.4f kg/s", obj.rpt(6)),
                sprintf("Pressure drop through tube at average mass flow = %.4f Pa", obj.rpt(2)),
                sprintf("Pressure drop due to minor losses at average mass flow = %.4f Pa", obj.rpt(3)),
                sprintf("Effectiveness of hhx relative to tube material temperature = %.4f", obj.rpt(12)),
                sprintf("Blower power (per cylinder) = %.4f W", obj.rpt(15)),
                sprintf("Atomizing air compressor power (per cylinder) = %.4f W", obj.rpt(16))
            ];
        end 
    end

    methods (Static)
        function getParams = createUI(gridLayout, params)
            inputs = containers.Map;
            createPanel = @StirlingEngineApp.createInputPanel;
            createInput = @StirlingEngineApp.createNumericInput;

            gridLayout.ColumnWidth = {"fit", "fit", "fit"};
            gridLayout.RowHeight = "fit";

            leftSide = uigridlayout(          ...
                gridLayout,                   ...
                "ColumnWidth", {"fit"},       ...
                "RowHeight", {"fit", "fit"},  ...
                "Padding", 0                  ...
            );
            rightSide = uigridlayout(         ...
                gridLayout,                   ...
                "ColumnWidth", {"fit"},       ...
                "RowHeight", {"fit", "fit"},  ...
                "Padding", 0                  ...
            );
            tubesGrid = createPanel(leftSide, "Tubes");
            shellGrid = createPanel(leftSide, "Shell");
            finsGrid = createPanel(rightSide, "Fins");
            otherGrid = createPanel(rightSide, "Other Parameters");

            inputs("geometry.tubes.L_front") = createInput(  ...
                tubesGrid,                                   ...
                "Label", "Front Tube Length",                ...
                "Units", "m",                                ...
                "Value", params.geometry.tubes.L_front,      ...
                "LowerLimit", 0,                             ...
                "LowerLimitInclusive", "off"                 ...
            );
            inputs("geometry.tubes.L_rear") = createInput(  ...
                tubesGrid,                                  ...
                "Label", "Rear Tube Length",                ...
                "Units", "m",                               ...
                "Value", params.geometry.tubes.L_rear,      ...
                "LowerLimit", 0,                            ...
                "LowerLimitInclusive", "off"                ...
            );
            inputs("geometry.tubes.L_inactive") = createInput(  ...
                tubesGrid,                                      ...
                "Label", "Inactive Tube Length",                ...
                "Units", "m",                                   ...
                "Value", params.geometry.tubes.L_inactive,      ...
                "LowerLimit", 0,                                ...
                "LowerLimitInclusive", "off"                    ...
            );
            inputs("geometry.tubes.D_outer") = createInput(  ...
                tubesGrid,                                   ...
                "Label", "Outer Diameter",                   ...
                "Units", "m",                                ...
                "Value", params.geometry.tubes.D_outer,      ...
                "LowerLimit", 0,                             ...
                "LowerLimitInclusive", "off"                 ...
            );
            inputs("geometry.tubes.D_inner") = createInput(  ...
                tubesGrid,                                   ...
                "Label", "Inner Diameter",                   ...
                "Units", "m",                                ...
                "Value", params.geometry.tubes.D_inner,      ...
                "LowerLimit", 0,                             ...
                "LowerLimitInclusive", "off"                 ...
            );
            inputs("geometry.tubes.N_total") = createInput(  ...
                tubesGrid,                                   ...
                "Label", "Number of Tubes per cylinder",     ...
                "Value", params.geometry.tubes.N_total,      ...
                "IsInteger", true,                           ...
                "LowerLimit", 1                              ...
            );
            inputs("geometry.tubes.roughness") = createInput(   ...
                tubesGrid,                                      ...
                "Label", "Roughness of internal tube surface",  ...
                "Value", params.geometry.tubes.roughness,       ...
                "LowerLimit", 0,                                ...
                "LowerLimitInclusive", "off"                    ...
            );
            inputs("geometry.shell.R_outer") = createInput(  ...
                shellGrid,                                   ...
                "Label", "Outer Radius of Tube Centers",     ...
                "Units", "m",                                ...
                "Value", params.geometry.shell.R_outer,      ...
                "LowerLimit", 0,                             ...
                "LowerLimitInclusive", "off"                 ...
            );
            inputs("geometry.shell.R_inner") = createInput(  ...
                shellGrid,                                   ...
                "Label", "Inner Radius of Tube Centers",     ...
                "Units", "m",                                ...
                "Value", params.geometry.shell.R_inner,      ...
                "LowerLimit", 0,                             ...
                "LowerLimitInclusive", "off"                 ...
            );
            inputs("geometry.shell.V_header") = createInput(  ...
                shellGrid,                                    ...
                "Label", "Header volume (not in tubes)",      ...
                "Units", "m^3",                               ...
                "Value", params.geometry.shell.V_header,      ...
                "LowerLimit", 0,                              ...
                "LowerLimitInclusive", "off"                  ...
            );
            inputs("geometry.fins.thickness") = createInput(  ...
                finsGrid,                                     ...
                "Label", "Thickness",                         ...
                "Units", "m",                                 ...
                "Value", params.geometry.fins.thickness,      ...
                "LowerLimit", 0,                              ...
                "LowerLimitInclusive", "off"                  ...
            );
            inputs("geometry.fins.pitch") = createInput(  ...
                finsGrid,                                 ...
                "Label", "Pitch",                         ...
                "Units", "m",                             ...
                "Value", params.geometry.fins.pitch,      ...
                "LowerLimit", 0,                          ...
                "LowerLimitInclusive", "off"              ...
            );
            inputs("geometry.fins.L_fin") = createInput(  ...
                finsGrid,                                 ...
                "Label", "Fin length",                    ...
                "Units", "m",                             ...
                "Value", params.geometry.fins.L_fin,      ...
                "LowerLimit", 0,                          ...
                "LowerLimitInclusive", "off"              ...
            );
            uilabel(                            ...
                finsGrid,                       ...
                "Text", "Material for fins",    ...
                "HorizontalAlignment", "right"  ...
            );
            inputs("geometry.tubes.materialfin") = uidropdown(  ...
                finsGrid,                                       ...
                "Items", [                                      ...
                    "Stainless Steel",                          ...
                    "SS304",                                    ...
                    "Stellite21",                               ...
                    "Inconel",                                  ...
                    "Titanium",                                 ...
                    "AISI1010",                                 ...
                    "Nickel",                                   ...
                    "Multimet"                                  ...
                ],                                              ...
            "Value", params.geometry.tubes.materialfin          ...
            );
            uilabel(                            ...
                tubesGrid,                      ...
                "Text", "Material for tubes",   ...
                "HorizontalAlignment", "right"  ...
            );
            inputs("geometry.tubes.materialtube") = uidropdown(  ...
                tubesGrid,                                       ...
                "Items", [                                       ...
                    "Stainless Steel",                           ...
                    "SS304",                                     ...
                    "Stellite21",                                ...
                    "Inconel",                                   ...
                    "Titanium",                                  ...
                    "AISI1010",                                  ...
                    "Nickel",                                    ...
                    "Multimet"                                   ...
                ],                                               ...
                "Value", params.geometry.tubes.materialtube      ...
            );
            uilabel(                            ...
                otherGrid,                      ...
                "Text", "Correlation",          ...
                "HorizontalAlignment", "right"  ...
            );
            inputs("correlation") = uidropdown(  ...
                otherGrid,                       ...
                "Items", [                       ...
                    "steady",                    ...
                    "oscillating"                ...
                ],                               ...
                "Value", params.correlation      ...
            );

            getParams = @getParamsFunc;
            function r = getParamsFunc()
                r = struct;
                names = keys(inputs);
                for i = 1:length(names)
                    name = names{i};
                    nestedName = strsplit(name, ".");
                    currentValue = inputs(name).Value;
                    r = setfield(r, nestedName{:}, currentValue);
                end
            end
        end
    end
end
