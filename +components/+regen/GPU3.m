% GPU-3 Regenerator with the possibility to specify a bypass ratio

classdef GPU3 < handle
    properties (Constant)
        defaultParams = struct(                     ...
            "geometry", struct(                     ...
                "vol_h", 1e-6,                      ... %m^3, header volume
                "mesh", struct(                     ...
                    "material", "Stainless Steel",  ... %mesh material - must exist in util.properties.Solid
                    "D_wire", 0.0000406,            ... %m, wire diametr       
                    "pitch", 8386                   ... %1/m, wires per length
                ),                                  ...
                "shell", struct(                    ...
                    "diameter", 0.0226,             ... %m, inner diameter of regenerator canister
                    "length", 0.02261,              ... %m, length of regenerator canister
                    "number", 8                     ... %-, number of regenerators
                )                                   ...
            ),                                      ...
            "Q_parasitic", 0,                       ... %parasitic in addition to what is specified in GPU3_A working space model - should be set to zero
            "bypass", 0,                            ... %fraction of flow bypassing regenerator
            "correlationf", "Gedeon and Wood",      ... %correlation for friction factor - must be one recognized by wovenMeshFlow
            "correlationj", "Gedeon and Wood"       ... %correlation for friction factor - must be one recognized by wovenMeshFlow
        )
    end

    properties (SetAccess = private)
        % Interface Properties
        vol (1,1) double {mustBeReal}
        DT (1,1) double {mustBeReal}
        Q_parasitic (1,1) double {mustBeReal}
        DP (1,:) double {mustBeReal}

        % Internal Properties
        vol_h (1,1) double
        d (1,1) double
        m (1,1) double
        Dia (1,1) double
        L (1,1) double
        N (1,1) double
        phi (1,1) double
        r_h (1,1) double
        alpha (1,1) double
        A_f (1,1) double
        A_s (1,1) double
        sigma (1,1) double
        R_hyd (1,1) double
        H_dot_r (1,1) double
        correlationf (1,1) string
        correlationj (1,1) string
        meshMaterial (1,1) string
        bypass (1,1) double
        
        %Parameters for report
        eff (1,1) double %effectiveness
        NTU (1,1) double %number of transfer units
        U (1,1) double %utilization
        m_dot_avg (1,1) double %average mass flow rate (kg/s)
        Q_dot_par_ineff (1,1) double %enthalpy flow penalty due to ineffectiveness (W)
        DP_g (1,1) double %average pressure drop (Pa)
    end

    methods
        function obj = GPU3(params)
            obj.d = params.geometry.mesh.D_wire;
            obj.m = params.geometry.mesh.pitch;
            obj.Dia = params.geometry.shell.diameter;
            obj.N = params.geometry.shell.number;
            obj.L = params.geometry.shell.length;
            obj.Q_parasitic = params.Q_parasitic;
            obj.correlationf = params.correlationf;
            obj.correlationj = params.correlationj;
            obj.meshMaterial = params.geometry.mesh.material;
            obj.vol_h = params.geometry.vol_h;
            obj.bypass = params.bypass;

            % Calculate geometric parameters related to the packing using
            % relations from Compact Heat Exchangers, 3rd edition, pg. 45
            x_t = 1 / (obj.m * obj.d);
            obj.phi = 1 - pi / (4 * x_t);           %porosity
            obj.r_h = obj.d * (x_t / pi - 1 / 4);   %hydraulic radius
            obj.alpha = pi / (x_t * obj.d);         %specific surface area
            obj.A_f = obj.N * pi * ((obj.Dia/2)^2); %area for flow without packing, frontal area
            obj.A_s = obj.alpha * obj.L * obj.A_f;  %total surface area
            obj.sigma = (x_t - 1)^2 / x_t^2;        %open area for flow/frontal area
            obj.vol = obj.A_f * obj.L * obj.phi;    %void volume
        end

        function firstCallUpdate(obj, engine)
            % Provide an initial guess value for DT (before engine states are available)
            obj.DT = min(100, 0.1 * (engine.T_hot - engine.T_cold));
        end

        function update(obj, engine)
            % Update the value for DT based on the current engine state

            % Calculate average mass flow rate in the regenerator
            m_dot_avgs = 0.5 * (engine.stateValues.m_dot_kr + engine.stateValues.m_dot_rl);
            obj.m_dot_avg = engine.freq * trapz(  ...
                engine.stateValues.time,          ...
                abs(m_dot_avgs)                   ...
            );

            % Calculate average fluid properties in the regenerator at
            % mass average temperature and average pressure
            fluidProps = engine.fluid.allProps(engine.T_r, engine.P_ave);
            cp_g = fluidProps.CP;       %fluid specific heat capacity
            rho_g = fluidProps.rho;     %fluid density
            mu_g = fluidProps.mu;       %fluid viscosity
            
            % Mass flux & Reynolds number
            G = obj.m_dot_avg / (obj.phi*obj.A_f);  %mass flux is mass/flow area
            u_max = sqrt(2)*G/rho_g;  %maximum flow rate in regenerator assuming average density
            
            % Obtain pressure drop and heat transfer
            %steady flow behavior is used as a reference
            [DP_g_ss, h_ss] = util.wovenMeshFlow(fluidProps, G, obj.correlationj, obj.correlationf, obj.phi, obj.r_h, obj.A_s, obj.A_f, obj.sigma);
            [MF_DP, MF_h] = util.oscillatingFlow(fluidProps, 4*obj.r_h, engine.freq, u_max);
            obj.DP_g = DP_g_ss*MF_DP; %oscillating flow results obtained with multiplier
            h = h_ss*MF_h;
            obj.R_hyd = obj.DP_g / (obj.m_dot_avg / rho_g);  %Calculate hydraulic resistance - this is used for the DP function to get frictional pressure drop

            % Obtain mesh material density and specific heat capacity
            [rho_mesh, cm, ~] = util.properties.Solid(obj.meshMaterial, engine.T_r);

            obj.NTU = h*obj.A_s/(obj.m_dot_avg*cp_g);   %Number of transfer units

            mm = (1-obj.phi)*obj.A_f*obj.L*rho_mesh;  % mass of mesh
            obj.U = obj.m_dot_avg*cp_g/(2*engine.freq*mm*cm);   % utilization - ratio of capacitance of fluid to capacitance of packing
                %note factor of 2 in denominator is because blow time is
                %half of period

            [obj.eff] = util.balancedregenerator(obj.NTU,obj.U);
            obj.DT=(engine.T_l-engine.T_k)*(1-obj.eff + obj.bypass); %approach temperature difference

            %approximate parasitic due to regenerator ineffectiveness (included
            %implicity in model - do NOT add to Q_psrasitic
            obj.Q_dot_par_ineff=obj.m_dot_avg*fluidProps.CP*obj.DT/2;
            
        end

        function lastCallUpdate(obj, engine)
            % Update pressure drop values
            m_dot_avgs = 0.5 * (engine.stateValues.m_dot_kr + engine.stateValues.m_dot_rl);
            rho = engine.fluid.density(engine.T_r, engine.stateValues.P);
            V_dot = m_dot_avgs ./ rho;
            obj.DP = obj.R_hyd * V_dot;
        end
        
        function lines = report(obj)
            % Return a string array that will be included in the engine report
            % (This function is optional)
            lines = [
                sprintf("Porosity = %.4f", obj.phi),
                sprintf("Average mass flow rate = %.4f kg/s", obj.m_dot_avg),
                sprintf("Utilization = %.4f", obj.U),
                sprintf("Number of transfer units = %.4f", obj.NTU),
                sprintf("Effectiveness = %.4f", obj.eff),
                sprintf("Penalty due to regenerator ineffectiveness = %.4f W", obj.Q_dot_par_ineff),
                sprintf("Frictional pressure drop at average flow = %.4f Pa", obj.DP_g)
                ];
        end
    end

    methods (Static)
        function getParams = createUI(gridLayout, params)
            inputs = containers.Map;
            createPanel = @StirlingEngineApp.createInputPanel;
            createInput = @StirlingEngineApp.createNumericInput;

            gridLayout.ColumnWidth = {"fit", "fit", "fit"};
            gridLayout.RowHeight = "fit";
            leftSide = uigridlayout(          ...
                gridLayout,                   ...
                "ColumnWidth", {"fit"},       ...
                "RowHeight", {"fit", "fit"},  ...
                "Padding", 0                  ...
            );
            rightSide = uigridlayout(         ...
                gridLayout,                   ...
                "ColumnWidth", {"fit"},       ...
                "RowHeight", {"fit", "fit"},  ...
                "Padding", 0                  ...
            );

            correlationsPanel = uipanel(leftSide, "Title", "Correlations");
            correlationsGrid = uigridlayout(    ...
                correlationsPanel,              ...
                "ColumnWidth", {"fit", "fit"},  ...
                "RowHeight", {"fit", "fit"}     ...
            );
            meshGrid = createPanel(leftSide, "Mesh");
            shellGrid = createPanel(leftSide, "Shell");
            otherGrid = createPanel(rightSide, "Other Parameters");

            inputs("geometry.shell.diameter") = createInput(  ...
                shellGrid,                                    ...
                "Label", "Inner Diameter of Canister",        ...
                "Units", "m",                                 ...
                "Value", params.geometry.shell.diameter,      ...
                "LowerLimit", 0,                              ...
                "LowerLimitInclusive", "off"                  ...
            );
            inputs("geometry.shell.length") = createInput(  ...
                shellGrid,                                  ...
                "Label", "Length of Canister",              ...
                "Units", "m",                               ...
                "Value", params.geometry.shell.length,      ...
                "LowerLimit", 0,                            ...
                "LowerLimitInclusive", "off"                ...
            );
            inputs("geometry.shell.number") = createInput(  ...
                shellGrid,                                  ...
                "Label", "Number of Regenerators",          ...
                "Value", params.geometry.shell.number,      ...
                "IsInteger", true,                          ...
                "LowerLimit", 1                             ...
            );

            inputs("geometry.mesh.D_wire") = createInput(  ...
                meshGrid,                                  ...
                "Label", "Wire Diameter",                  ...
                "Units", "m",                              ...
                "Value", params.geometry.mesh.D_wire,      ...
                "LowerLimit", 0,                           ...
                "LowerLimitInclusive", "off"               ...
            );
            inputs("geometry.mesh.pitch") = createInput(  ...
                meshGrid,                                 ...
                "Label", "Pitch",                         ...
                "Units", "1/m",                           ...
                "Value", params.geometry.mesh.pitch,      ...
                "LowerLimit", 0,                          ...
                "LowerLimitInclusive", "off"              ...
            );
            uilabel(                            ...
                meshGrid,                       ...
                "Text", "Material",             ...
                "HorizontalAlignment", "right"  ...
            );
            inputs("geometry.mesh.material") = uidropdown(  ...
                meshGrid,                                   ...
                "Items", [                                  ...
                    "Stainless Steel",                      ...
                    "Tin",                                  ...
                    "Titanium",                             ...
                    "Brass"                                 ...
                ],                                          ...
                "Value", params.geometry.mesh.material      ...
            );

            uilabel(                            ...
                correlationsGrid,               ...
                "Text", "Friction Factor",      ...
                "HorizontalAlignment", "right"  ...
            );
            inputs("correlationf") = uidropdown(  ...
                correlationsGrid,                 ...
                "Items", [                        ...
                    "Kays and London",            ...
                    "Gedeon and Wood"             ...
                ],                                ...
                "Value", params.correlationf      ...
            );
            uilabel(                            ...
                correlationsGrid,               ...
                "Text", "Colburn J-factor",     ...
                "HorizontalAlignment", "right"  ...
            );
            inputs("correlationj") = uidropdown(  ...
                correlationsGrid,                 ...
                "Items", [                        ...
                    "Kays and London",            ...
                    "Gedeon and Wood"             ...
                ],                                ...
                "Value", params.correlationj      ...
            );

            inputs("geometry.vol_h") = createInput(  ...
                otherGrid,                           ...
                "Label", "Header Volume",            ...
                "Units", "m^3",                      ...
                "Value", params.geometry.vol_h,      ...
                "LowerLimit", 0                      ...
            );
            inputs("bypass") = createInput(         ...
                otherGrid,                          ...
                "Label", "Parasitic Thermal Loss",  ...
                "Value", params.bypass,             ...
                "LowerLimit", 0,                    ...
                "UpperLimit", 1                     ...
            );
            inputs("Q_parasitic") = createInput(    ...
                otherGrid,                          ...
                "Label", "Parasitic Thermal Loss",  ...
                "Units", "W",                       ...
                "Value", params.Q_parasitic,        ...
                "LowerLimit", 0                     ...
            );

            getParams = @getParamsFunc;
            function r = getParamsFunc()
                r = struct;
                names = keys(inputs);
                for i = 1:length(names)
                    name = names{i};
                    nestedName = strsplit(name, ".");
                    currentValue = inputs(name).Value;
                    r = setfield(r, nestedName{:}, currentValue);
                end
            end
        end
    end
end
